/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: RadarMessage.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf';
export class RadarMessage extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          radar?: number;
          spokes?: RadarMessage.Spoke[];
        }
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [2],
      this.#one_of_decls
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('radar' in data && data.radar != undefined) {
        this.radar = data.radar;
      }
      if ('spokes' in data && data.spokes != undefined) {
        this.spokes = data.spokes;
      }
    }
  }
  get radar() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set radar(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get spokes() {
    return pb_1.Message.getRepeatedWrapperField(
      this,
      RadarMessage.Spoke,
      2
    ) as RadarMessage.Spoke[];
  }
  set spokes(value: RadarMessage.Spoke[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    radar?: number;
    spokes?: ReturnType<typeof RadarMessage.Spoke.prototype.toObject>[];
  }): RadarMessage {
    const message = new RadarMessage({});
    if (data.radar != null) {
      message.radar = data.radar;
    }
    if (data.spokes != null) {
      message.spokes = data.spokes.map((item) =>
        RadarMessage.Spoke.fromObject(item)
      );
    }
    return message;
  }
  toObject() {
    const data: {
      radar?: number;
      spokes?: ReturnType<typeof RadarMessage.Spoke.prototype.toObject>[];
    } = {};
    if (this.radar != null) {
      data.radar = this.radar;
    }
    if (this.spokes != null) {
      data.spokes = this.spokes.map((item: RadarMessage.Spoke) =>
        item.toObject()
      );
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.radar != 0) writer.writeUint32(1, this.radar);
    if (this.spokes.length)
      writer.writeRepeatedMessage(2, this.spokes, (item: RadarMessage.Spoke) =>
        item.serialize(writer)
      );
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RadarMessage {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new RadarMessage();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.radar = reader.readUint32();
          break;
        case 2:
          reader.readMessage(message.spokes, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              2,
              RadarMessage.Spoke.deserialize(reader),
              RadarMessage.Spoke
            )
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): RadarMessage {
    return RadarMessage.deserialize(bytes);
  }
}
export namespace RadarMessage {
  export class Spoke extends pb_1.Message {
    #one_of_decls: number[][] = [[2], [4], [6], [7]];
    constructor(
      data?:
        | any[]
        | ({
            angle?: number;
            range?: number;
            data?: Uint8Array;
          } & (
            | {
                bearing?: number;
              }
            | {
                time?: number;
              }
            | {
                lat?: number;
              }
            | {
                lon?: number;
              }
          ))
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('angle' in data && data.angle != undefined) {
          this.angle = data.angle;
        }
        if ('bearing' in data && data.bearing != undefined) {
          this.bearing = data.bearing;
        }
        if ('range' in data && data.range != undefined) {
          this.range = data.range;
        }
        if ('time' in data && data.time != undefined) {
          this.time = data.time;
        }
        if ('lat' in data && data.lat != undefined) {
          this.lat = data.lat;
        }
        if ('lon' in data && data.lon != undefined) {
          this.lon = data.lon;
        }
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get angle() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set angle(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get bearing() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set bearing(value: number) {
      pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
    }
    get has_bearing() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get range() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set range(value: number) {
      pb_1.Message.setField(this, 3, value);
    }
    get time() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set time(value: number) {
      pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
    }
    get has_time() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get lat() {
      return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set lat(value: number) {
      pb_1.Message.setOneofField(this, 6, this.#one_of_decls[2], value);
    }
    get has_lat() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get lon() {
      return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set lon(value: number) {
      pb_1.Message.setOneofField(this, 7, this.#one_of_decls[3], value);
    }
    get has_lon() {
      return pb_1.Message.getField(this, 7) != null;
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(
        this,
        5,
        new Uint8Array(0)
      ) as Uint8Array;
    }
    set data(value: Uint8Array) {
      pb_1.Message.setField(this, 5, value);
    }
    get _bearing() {
      const cases: {
        [index: number]: 'none' | 'bearing';
      } = {
        0: 'none',
        2: 'bearing'
      };
      return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    get _time() {
      const cases: {
        [index: number]: 'none' | 'time';
      } = {
        0: 'none',
        4: 'time'
      };
      return cases[pb_1.Message.computeOneofCase(this, [4])];
    }
    get _lat() {
      const cases: {
        [index: number]: 'none' | 'lat';
      } = {
        0: 'none',
        6: 'lat'
      };
      return cases[pb_1.Message.computeOneofCase(this, [6])];
    }
    get _lon() {
      const cases: {
        [index: number]: 'none' | 'lon';
      } = {
        0: 'none',
        7: 'lon'
      };
      return cases[pb_1.Message.computeOneofCase(this, [7])];
    }
    static fromObject(data: {
      angle?: number;
      bearing?: number;
      range?: number;
      time?: number;
      lat?: number;
      lon?: number;
      data?: Uint8Array;
    }): Spoke {
      const message = new Spoke({});
      if (data.angle != null) {
        message.angle = data.angle;
      }
      if (data.bearing != null) {
        message.bearing = data.bearing;
      }
      if (data.range != null) {
        message.range = data.range;
      }
      if (data.time != null) {
        message.time = data.time;
      }
      if (data.lat != null) {
        message.lat = data.lat;
      }
      if (data.lon != null) {
        message.lon = data.lon;
      }
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        angle?: number;
        bearing?: number;
        range?: number;
        time?: number;
        lat?: number;
        lon?: number;
        data?: Uint8Array;
      } = {};
      if (this.angle != null) {
        data.angle = this.angle;
      }
      if (this.bearing != null) {
        data.bearing = this.bearing;
      }
      if (this.range != null) {
        data.range = this.range;
      }
      if (this.time != null) {
        data.time = this.time;
      }
      if (this.lat != null) {
        data.lat = this.lat;
      }
      if (this.lon != null) {
        data.lon = this.lon;
      }
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.angle != 0) writer.writeUint32(1, this.angle);
      if (this.has_bearing) writer.writeUint32(2, this.bearing);
      if (this.range != 0) writer.writeUint32(3, this.range);
      if (this.has_time) writer.writeUint64(4, this.time);
      if (this.has_lat) writer.writeInt64(6, this.lat);
      if (this.has_lon) writer.writeInt64(7, this.lon);
      if (this.data.length) writer.writeBytes(5, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Spoke {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Spoke();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.angle = reader.readUint32();
            break;
          case 2:
            message.bearing = reader.readUint32();
            break;
          case 3:
            message.range = reader.readUint32();
            break;
          case 4:
            message.time = reader.readUint64();
            break;
          case 6:
            message.lat = reader.readInt64();
            break;
          case 7:
            message.lon = reader.readInt64();
            break;
          case 5:
            message.data = reader.readBytes();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Spoke {
      return Spoke.deserialize(bytes);
    }
  }
}
